# 计算机操作系统 - 内存管理
<!-- GFM-TOC -->
* [计算机操作系统 - 内存管理](#计算机操作系统---内存管理)
    * [虚拟内存](#虚拟内存)
    * [分页系统地址映射](#分页系统地址映射)
    * [页面置换算法](#页面置换算法)
        * [1. 最佳](#1-最佳)
        * [2. 最近最久未使用](#2-最近最久未使用)
        * [3. 最近未使用](#3-最近未使用)
        * [4. 先进先出](#4-先进先出)
        * [5. 第二次机会算法](#5-第二次机会算法)
        * [6. 时钟](#6-时钟)
    * [分段](#分段)
    * [段页式](#段页式)
    * [分页与分段的比较](#分页与分段的比较)
<!-- GFM-TOC -->

## 演变历程

将一个程序作为一整段进行管理，从而形成了纯粹分段（固定加载地址、固定分区、非固定分区、交换）管理模式。

但纯粹分段存在重大缺陷。由于此种模式下一个程序只有一段，从而导致内存空间增长困难、外部碎片、程序不能超过物理内存容量、一个程序必须同时加载到内存才能执行（除非使用overlay）等诸多缺点。而为了克服这些缺点，我们引入了页式内存管理模式。

虽然页式内存管理模式克服了纯粹分段的一系列缺点，但又存在共享不方便、一个程序只能在一个虚地址空间增长的问题。而为了解决这个问题，我们引入了逻辑分段。虽然都是分段，但已经不在一个层次上。逻辑分段将一个程序按逻辑关系分解为多个段，从而扩大了程序可以使用的虚拟地址空间并解决了共享难的问题。但逻辑分段终究还是分段，自然又引入了分段的缺点。而要克服这些缺点，自然又想到了分页。这样我们就来到了段页式管理模式。



## 1. 固定地址的内存管理

不需要地址翻译，速度快；

第1个缺点是整个程序要加载到内存空间中去。这样将导致比物理内存大的程序无法运行。第2个缺点是，只运行一个程序造成资源浪费。如果一个程序很小，虽然所用内存空间小，但剩下的内存空间也无法使用。第3个缺点是可能无法在不同的操作系统下运行，因为不同操作系统占用的内存空间大小可能不一样，使得用户程序的起始地址可能不一样。这样在一个系统环境下编译出来的程序很可能无法在另一个系统环境下执行。

## 2. 基址和限制寄存器的管理模式

动态地址翻译：用户进程发出的虚拟地址由MMU翻译成物理地址

程序发出的地址需要和极限比较大小；如果大于极限，则属非法访问。在这个时候我们将陷入内核，终止进程（在个别操作系统上，也可能进入一个异常处理的过程）；否则将基址加上偏移获得物理地址，就可以合法访问这个物理地址。

### 固定分区

将内存划区，将每个程序放进不同区里面

在固定分区下，基址就是固定内存分区中各个区域的起始内存地址，而极限则是所加载程序的长度（记住，不是内存各个分区的上限）。

缺点：一是程序大小和分区大小的匹配不容易令人满意；二是很僵硬，如果有个程序比最大的分区大怎么办呢？三是地址空间无法增长，如果程序在运行时内存需求增长怎么办？

### 非固定分区

除了划分给操作系统的空间外，其余的内存空间是作为一个整体存在的。当一个程序需要占用内存空间时，就在该片空间里面分出一个大小刚刚满足程序所需的空间；再来一个程序，则在剩下的空间里面再这样分出一块来。

如果空间不够可以使用**交换**技术，将某些进程倒回硬盘，再放入新程序；通过交换技术，可以同时运行大于内存大小的程序，但**单一程序不能超过内存大小**！

需要闲置内存管理：位图法、链表表示法

缺点：频繁交换导致内存碎片化；地址空间增长困难



## 3. 分页

分页系统的核心就是将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如4KB、8KB或16KB等，并以页面作为内存空间的最小分配单位，一个程序的一个页面可以存放在任意一个物理页面里。这样，由于物理空间是页面的整数倍，并且空间分配以页面为单位，将不会再产生外部碎片。同时，由于一个虚拟页面可以存放在任何一个物理页面里，空间增长也容易解决：只需要分配额外的虚拟页面，并找到一个闲置的物理页面存放即可。

为了解决程序比内存大的问题，我们可以允许一个进程的部分虚拟页面存放在物理页面之外，也就是磁盘上。在需要访问这些外部虚拟页面时，再将其调入物理内存。由此，交换系统的所有缺陷均被克服。

缺点：页表占据大量的内存空间；地址的翻译增加了内存访问次数（先访问页表再访问实际地址）降低了系统效率，可以通过TLB改善



## 虚拟内存

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。注意虚拟内存和虚拟地址的区别：https://blog.csdn.net/qq51931373/article/details/32730029

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，发生缺页中断，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0\~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>

## 分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个**虚拟地址分成两个部分**，一部分存储**页面号**，一部分存储**偏移量**（在该页内的偏移）。

下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行<u>索引定位</u>。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。虚拟地址对应的物理地址为 （110 000000000100）。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><center>图从下往上看</center>



## 针对大内存的页表

### 1.多级页表

在多级页表结构下，页表根据存放的内容可分为：顶级页表、一级页表、二级页表、三级页表等。顶级页表里面存放的是一级页表的信息，一级页表里面存放的是二级页表的信息，以此类推，到最后一级页表存放的才是虚拟页面到物理页面的映射。一个程序在运行时其顶级页表常驻内存，而次级页表则按需要决定是否存放在物理内存。

通过翻译快表（Translation Look-Aside Buffer,TLB）改善多级页表的效率，翻译时先在TLB查找



Linux中每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。

<img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470330729_28397F90C2D7C059A122BFF0B4DFD63A">

<center>Linux的四级页表</center>

### 2.倒排页表

对于64位机，地址空间有2^64bytes大（假如一个地址存储1byte），页表的表项将会非常多（2^64/4KB = 2^52），所以用实际内存的页框数目（如1G RAM / 4KB page），一个页框有一个表项

由于反转页表存放的是物理地址到虚拟地址的映射，而CPU发出的地址却是虚拟地址，这就造成页表查找困难。不过，这个问题可以通过散列来解决，即将虚拟页号散列到物理页号，然后以这个散列出来的物理页号作为索引在反转页表里面查找。但由于虚拟页面远多于物理页面的缘故，多个虚拟页号将很可能散列到同一个物理页号对应的记录里。这样，在散列后，仍然需要检查该虚拟页面是否在物理内存内，而这种检查需要进行多次内存访问。如果使用开放式散列，则散列表的尺寸将随着程序使用的虚拟页面数的增加而增加。



## 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中（页表中记录了该页不在内存），就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

### 1. 最佳

> OPT, Optimal replacement algorithm

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

```html
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
```

开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

### 2. 最近最久未使用（LRU）

> LRU, Least Recently Used

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

一种方式是记录页面被访问的次数，定期清0

另一种实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，所以这种方式实现的 LRU 代价很高。

```html
4，7，0，7，1，0，1，2，1，2，6
```

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>
更为现实的方法是矩阵法



### 3. 最近未使用（NRU）

> NRU, Not Recently Used

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时（如时钟中断时）被清零。可以将页面分成以下四类：

- R=0，M=0 没有被访问，没有被修改
- R=0，M=1 没有被访问，已被修改
- R=1，M=0 已被访问，没有被修改
- R=1，M=1 已被访问，已被修改

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

### 4. 先进先出

> FIFO, First In First Out

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面换出，导致缺页率升高。

### 5. 第二次机会算法

FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>

### 6. 时钟

> Clock

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>

## 4. 分段

下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果一个进程只能占有一个虚拟地址空间，动态增长的特点会导致覆盖问题的出现。*当然，编译器在工作时会为每个数据结构多分配一些空间来容纳其随后的增长。而且这些空间的大小都经过经验数据测试，可以应对大多数情况下数据结构增长的需要。但是，谁也不能保障不会碰到一个很大的程序，以致某个数据结构的增长空间不够的情况。*

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>

分段管理就是将一个程序按照逻辑单元分成多个程序段，**每一个段使用自己单独的虚拟地址空间**（一个程序将占据多个虚拟地址空间）。每个段的长度可以不同，并且可以动态增长。

在段式虚拟存储系统中，**虚拟地址由段号和段内地址组成**，虚拟地址到实存地址的变换通过段表来实现。每个程序设置一个段表，段表的每一个表项对应一个段，每个表项至少包括三个字段：有效位（指明该段是否已经调入主存）、段起址(该段在实存中的首地址)和段长（记录该段的实际长度）。

绝对地址=根据段号找到段表中的起始地址+段内地址 (如果段内地址超过限长则产生“地址越界”程序性中断事件达到存储保护)

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>

分段管理的缺点也十分明显。既然是分段，就存在前面基本内存管理时介绍过的**缺点：外部碎片**（内存中不同段间的空闲）和**一个段必须全部加载到内存**（个人想法是分段内存管理是以段为单位管理的，所以不可能把一个段拆开放一部分回磁盘）。



## 5. 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

由于段页式管理模式是在段里面分页，而每个段占据一个虚地址空间，这就意味着一个程序将对应多个页表。那么一个程序如何管理多个页表呢？简单！在分页系统里已经介绍过多级页表。在这里我们只需要将这些页表作为次级页表，而在次级页表上面增加一层段表（相当于多级页表里面的顶级页表）。由段号在段表里面获得所应该使用的页表，然后在该页表里面查找物理页面号

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101120907221610442317(1).png" style="zoom: 67%;"  >



<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101120913021610442766(1).png" style="zoom:67%;" >



一个进程按逻辑划分成不同的段，不同的段分页放到内存中

**逻辑地址**----- >段号、段内页号、页内地址

段表寄存器--- >段表始址

段号+段表始址---- >页表始址

页表始址+段内页号----->存储块号

块号+页内地址------>**物理地址**

 <img src="https://img-blog.csdn.net/20131031092005921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"  />

## 分页与分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的长度可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
- 分段不会出现分页系统下一个页面里面可能同时包含数据和代码而造成共享不便的问题
- 分段有外部碎片和一个段必须加载到内存的缺点



## 内存对齐（字节对齐）

```c++
struct A{
	char a,
    int b,
    short c
};
```

一个结构体，简单看上去大小是1+4+2 bytes，但实际它在内存中占的大小并不止这么小，因为编译器对结构体进行了内存对齐

### 什么是内存对齐

内存对齐主要遵循下面三个原则:

1. 结构体变量的**起始地址**能够被其最宽的成员大小整除
2. 结构体每个成员相对于**起始地址的偏移**能够被其**自身大小整除**，如果不能则在**前一个成员后面**补充字节
3. 结构体总体大小能够**被最宽的成员的大小**整除，如不能则在**后面**补充字节
4. *编译器在编译时可以指定对齐大小#program back (size)，但如果指定的大小比结构中最大成员的有效对齐还大那么指定值将无效*

如果默认的对齐大小是4，结构体a的起始地址为0x0000，能够被最宽的数据成员大小(这里是int， 大小为4，有效对齐大小也是4)整除，姑char a的从0x0000开始存放占用一个字节即0x0000~0x0001，然后是int b，其大小为4，故要满足2，需要从0x0004开始，所以在char a后填充三个字节，因此a对齐后占用的空间是0x0000~0x0003，b占用的空间是0x0004~0x0007, 然后是short c其大小是2，故从0x0008开始占用两个字节，即0x0008~0x0009。 此时整个结构体占用的空间是0x0000~0x0009， 占用10个字节，10%4 ！= 0, 不满足第三个原则，所以需要在后面补充两个字节，即最后内存对齐后占用的空间是0x0000~0x000B，一共12个字节。

### 为什么要内存对齐

cpu从内存读取数据并不是一个一个字节去读的，而是以一定宽度如4bytes或者8bytes进行的，具体原因：https://zhuanlan.zhihu.com/p/83449008

假设cpu以4字节为单位从内存读取数据，如果有一个int它的地址是从0x0003~0x0006，那么cpu要先读取0x0000~0x0003的四个字节，再读取0x0004~0x0007的四个字节才能得到这个int；这样需要两次内存访问，而内存访问相对于cpu计算速度要慢得多（计组知识，记得大概差100倍），所以再编译时就进行内存对齐以确保运行时的速度。