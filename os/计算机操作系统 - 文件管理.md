# 计算机操作系统 - 文件管理

> https://zhuanlan.zhihu.com/p/183238194
>
> https://www.cnblogs.com/cxuanBlog/p/12565601.html



文件结构分为字节序列、记录序列、树

文件以**魔数**开始，表示这是一个可执行文件

**顺序存取文件**：从头读取文件的全部字节或记录，但不能跳过某一些内容

**随机存取文件**：能以任意次序读取其中字节或记录的文件



## 目录

层次目录系统

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101130744241610523844(1).png" style="zoom: 80%;" >



## 文件系统

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_210113073348file%20sys.png" style="zoom:80%;" >



<img src="http://images2015.cnblogs.com/blog/1066890/201703/1066890-20170310204827311-253347735.png">

<center>ext4文件系统</center>



### 文件的实现

#### 1.连续分配

文件的块连续分布在磁盘上，实现简单，读操作性能好

随时间推移，磁盘会变得零碎，文件间有很多没用到的空闲块



#### 2.链表分配

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101130750561610524240(1).png" style="zoom: 80%;" >



#### 3.在内存中采用表的链表分配

记录文件块指向的下一个文件块，避免需要从磁盘读出一个文件块才能访问它的下一个文件块

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101130754361610524461(1).png" style="zoom: 80%;" >

#### 4. index-node

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101130800261610524815(1).png" style="zoom: 80%;" >



<img src="https://pic4.zhimg.com/80/v2-0c16919bcad17d1391f162e0363229b7_720w.jpg" alt="img" style="zoom: 67%;" />
<center>ext2 inode</center>

Linux.ext4文件系统.inode和extenthttps://blog.csdn.net/stringnewname/article/details/73740155

extent_tree https://blog.csdn.net/lieye_leaves/article/details/54800344 *实际是一个B+树*

### 目录的实现

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101130842221610527295(1).png" style="zoom:80%;" >



<img src="https://pic1.zhimg.com/80/v2-89f1e2f2d2a2cb232920d2df16a5f3f4_720w.jpg" style="zoom:80%;" >

#### 处理目录项中的文件名

如果文件名定长，那么会浪费没有用到的长度，所以目录项是不定长的

a方式目录项以目录项长度开始，将文件名跟在属性后面，这种方式缺点是如果移走了文件，原来这个位置的空隙对于新文件并不总是那么适合

b方式目录项是定长的，文件名放在目录后面的堆中 

<img src="https://images.cnblogs.com/cnblogs_com/songsongww/1915225/o_2101130846271610527573(1).png" style="zoom:67%;" >



到目前为止的所有设计中，**在需要查找文件名时**，所有的方案都是**线性的从头到尾对目录进行搜索。对于特别长的目录，线性搜索的效率很低**。**提高文件检索效率的一种方式是在每个目录上使用`哈希表(hash table)`**，也叫做散列表。我们假设表的大小为 n，在输入文件名时，文件名被散列在 0 和 n - 1 之间，例如，它被 n 除，并取余数。或者对构成文件名字的字求和或类似某种方法。

无论采用哪种方式，**在添加一个文件时都要对与散列值相对 应的散列表进行检查**。如果没有使用过，就会将一个指向目录项的指针指向这里。文件目录项紧跟着哈希表后面。如果已经使用过，就会构造一个链表（这种构造方式是不是和 HashMap 使用的数据结构一样？），链表的表头指针存放在表项中，并通过哈希值将所有的表项相连。

<img src="https://img2020.cnblogs.com/blog/1515111/202003/1515111-20200325131154355-1180541609.png" style="zoom:50%;" >



### 共享文件

当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图 **C 的一个文件也出现在了 B 的目录下**。

<img src="https://img2020.cnblogs.com/blog/1515111/202003/1515111-20200325131202241-1899878373.png" style="zoom: 45%;" >

如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 `链接(link)`。那么文件系统现在就是一个 `有向无环图(Directed Acyclic Graph, 简称 DAG)`，而不是一棵树了。

> 在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个`有向无环图`



`共享文件`很方便，但这也会带来一些问题。如果目录中包含磁盘地址，则当链接文件时，**必须把 C 目录中的磁盘地址复制到 B 目录中**。如果 B 或者 C 随后又向文件中添加内容，则仅在执行追加的用户的目录中显示新写入的数据块。这种变更将会对其他用户不可见，从而破坏了共享的目的。



#### 两种解决方案

- 第一种解决方案，磁盘块不列入目录中，而是会把磁盘块放在与文件本身相关联的小型数据结构中。目录将**指向**这个小型数据结构。这是 `UNIX` 中使用的方式（小型数据结构就是 i-node），即Linux的**硬链接**，ln命令。
- 在第二种解决方案中，通过让系统建立一个类型为 `LINK` 的新文件，并把该文件放在 B 的目录下，使得 B 与 C 建立链接。**新的文件中只包含了它所链接的文件的路径名**。当 B 想要读取文件时，操作系统会检查 B 的目录下存在一个类型为 LINK 的文件，进而找到该链接的文件和路径名，然后再去读文件，这种方式称为 `符号链接(symbolic linking)`。这是Linux的**软连接**，ln命令参数s：ln -s

上面的每一种方法都有各自的缺点，在第一种方式中，B 链接到共享文件时，inode 记录文件的所有者为 C。**建立一个链接并不改变所有关系**，如下图所示。

<img src="https://img2020.cnblogs.com/blog/1515111/202003/1515111-20200325131233539-338096445.png" style="zoom:50%;" >

第一开始的情况如图 a 所示，此时 C 的目录的所有者是 C ，当目录 B 链接到共享文件时，并不会改变 C 的所有者关系，只是把计数 + 1，所以此时系统知道目前有多少个目录指向这个文件。然后 C 尝试删除这个文件，这个时候有个问题，**如果 C 把文件移除并清除了 inode 的话，那么 B 会有一个目录项指向无效的节点**。**如果 inode 以后分配给另一个文件，则 B 的链接指向一个错误的文件**。系统通过 inode 可知文件仍在被引用，但是没有办法找到该文件的全部目录项以删除它们。指向目录的指针不能存储在 inode 中，原因是有可能有无数个这样的目录。

所以我们能做的**就是删除 C 的目录项，但是将 inode 保留下来，并将计数设置为 1** ，如上图 c 所示。c 表示的是只有 B 有指向该文件的目录项，而该文件的前者是 C 。如果系统进行记账操作的话，那么 C 将继续为该文件付账直到 B 决定删除它，如果是这样的话，只有到计数变为 0 的时刻，才会删除该文件。

对于`符号链接`，以上问题不会发生，只有真正的文件所有者才有一个指向 inode 的指针。链接到该文件上的用户只有路径名，没有指向 inode 的指针。当文件所有者删除文件时，该文件被销毁。以后若试图通过符号链接访问该文件将会失败，因为系统不能找到该文件。删除符号链接不会影响该文件。

符号链接的问题是**需要额外的开销**。1.必须读取包含路径的文件，然后要一个部分接一个部分地扫描路径，直到找到 inode 。这些操作也许需要很多次额外的磁盘访问。2.每个符号链接都需要额外的 inode 和额外的一个磁盘块用于存储路径，虽然如果路径名很短，作为一种优化，系统可以将它存储在 inode 中。符号链接有一个优势，即只要**简单地提供一个机器的网络地址以及文件在该机器上驻留的路径**，就可以连接全球任何地方机器上的文件。

还有另一个由链接带来的问题，在符号链接和其他方式中都存在。如果允许链接，文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被链接的文件。例如，一个将某一目录及其子目录下的文件转存到磁带上的程序有可能多次复制一个被链接的文件。进而，如果接着把磁带读入另一台机器，除非转出程序具有智能，否则被链接的文件将被两次复制到磁盘上，而不是只是被链接起来。



## 日志文件系统

虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做`日志文件系统`，它会记录系统下一步将要做什么的日志。微软的 `NTFS` 文件系统、Linux 的 `ext3` 就使用了此日志。 `OS X` 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 `移除文件` ，这个操作在 UNIX 中需要三个步骤完成：

- 在目录中删除文件
- 释放 inode 到空闲 inode 池
- 将所有磁盘块归还给空闲磁盘池。

在 Windows 中，也存在类似的步骤。不存在系统崩溃时，这些步骤的执行顺序不会带来问题。但是一旦系统崩溃，就会带来问题。假如在第一步完成后系统崩溃。inode 和文件块将不会被任何文件获得，也不会再分配；它们只存在于废物池中的某个地方，并因此减少了可利用的资源。如果崩溃发生在第二步后，那么只有磁盘块会丢失。`日志文件系统`保留磁盘写入期间对文件系统所做的更改的日志或日志，该日志可用于快速重建可能由于系统崩溃或断电等事件而发生的损坏。

> 一般文件系统崩溃后必须运行 `fsck（文件系统一致性检查）`实用程序。

为了让日志能够正确工作，被写入的日志操作必须是 `幂等的(idempotent)`，它意味着只要有必要，它们就可以重复执行很多次，并不会带来破坏。像操作 **更新位表并标记 inode k 或者块 n 是空闲的** 可以重复执行任意次。同样地，查找一个目录并且删除所有叫 `foobar` 的项也是幂等的。相反，把从 inode k 新释放的块加入空闲表的末端不是幂等的，因为它们可能已经被释放并存放在那里了。

<img src="https://img2020.cnblogs.com/blog/1515111/202003/1515111-20200325131259497-1243298981.png" alt="img" style="zoom: 33%;" />

为了增加可靠性，一个文件系统可以引入数据库中 `原子事务(atomic transaction)` 的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。这样，文件系统就会知道它必须完成所有的动作，要么就一个不做。



## 虚拟文件系统

同一台计算机上或者在同一个操作系统下使用很多不同的文件系统。Windows 中的主要文件系统是 `NTFS 文件系统`，但，它还有一些其他的例如旧的 `FAT -32` 或`FAT -16` 驱动器或分区。Windows 通过指定不同的盘符来处理这些不同的文件系统，比如 `C:`，`D:` 等。盘符可以显示存在也可以隐式存在，如果你想找指定位置的文件，那么盘符是显示存在；如果当一个进程打开一个文件时，此时盘符是隐式存在，所以 Windows 知道向哪个文件系统传递请求。

相比之下，UNIX 采用了一种不同的方式，即 **UNIX 把多种文件系统整合到一个统一的结构中**。一个 Linux 系统可以使用 `ext2` 作为根文件系统，`ext3` 分区装载在 `/usr` 下，另一块采用 `Reiser FS` 文件系统的硬盘装载到 `/home`下，以及一个 ISO 9660 的 CD - ROM 临时装载到 `/mnt` 下。**从用户的观点来看，只有一个文件系统层级，但是事实上它们是由多个文件系统组合而成，对于用户和进程是不可见的**。

UNIX 操作系统使用一种 `虚拟文件系统(Virtual File System, VFS)` 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构

<img src="https://img2020.cnblogs.com/blog/1515111/202003/1515111-20200325131309542-676201098.png" alt="img" style="zoom: 33%;" />

还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个`代理`来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 `POSIX 系统调用`，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 `上层` 接口，这个接口就是著名的 POSIX 接口。

VFS 也有一个对于实际文件的 `下层` 接口，就是上图中标记为 VFS 的接口。这个接口包含许多功能调用，这样 VFS 可以使每一个文件系统完成任务。因此，要创建一个可以与 VFS 一起使用的新文件系统，新文件系统的设计者必须确保它提供了 VFS 要求的功能。一个明显的例子是从磁盘读取特定的块，然后将其放入文件系统的缓冲区高速缓存中，然后返回指向该块的指针的函数。 因此，VFS具有两个不同的接口：上一个到用户进程，下一个到具体文件系统。

当系统启动时，根文件系统在 VFS 中注册。另外，当装载其他文件时，不管在启动时还是在操作过程中，它们也必须在 VFS 中注册。当一个文件系统注册时，根文件系统注册到 VFS。另外，在引导时或操作期间挂载其他文件系统时，它们也必须向 VFS 注册。当文件系统注册时，其基本作用是提供 VFS 所需功能的地址列表、调用向量表、或者 VFS 对象。因此一旦文件系统注册到 VFS，它就知道从哪里开始读取数据块。

装载文件系统后就可以使用它了。比如，如果一个文件系统装载到 `/usr` 并且一个进程调用它：

```shell
open("/usr/include/unistd.h",O_RDONLY)
```

当解析路径时， VFS 看到新的文件系统被挂载到 `/usr`，并且通过搜索已经装载文件系统的超级块来确定它的超块。然后它找到它所转载的文件的根目录，在那里查找路径 `include/unistd.h`。然后 VFS 创建一个 vnode 并调用实际文件系统，以返回所有的在文件 inode 中的信息。这个信息和其他信息一起复制到 vnode （内存中）。而这些其他信息中最重要的是指向包含调用 vnode 操作的函数表的指针，比如 read、write 和 close 等。

当 vnode 被创建后，为了进程调用，VFS 在文件描述符表中创建一个表项，并将它指向新的 vnode，最后，VFS 向调用者返回文件描述符，所以调用者可以用它去 read、write 或者 close 文件。

当进程用文件描述符进行一个读操作时，VFS 通过进程表和文件描述符确定 vnode 的位置，并跟随指针指向函数表，这样就调用了处理 read 函数，运行在实际系统中的代码并得到所请求的块。VFS 不知道请求时来源于本地硬盘、还是来源于网络中的远程文件系统、CD-ROM 、USB 或者其他介质，所有相关的数据结构欧如下图所示

<img src="https://img2020.cnblogs.com/blog/1515111/202003/1515111-20200325131347596-1973502003.png" alt="img" style="zoom: 33%;" />

**从调用者进程号和文件描述符开始，进而是 vnode，读函数指针，然后是对实际文件系统的访问函数定位**。



## 文件系统管理

### 空闲空间管理

前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要保存一个数据块，我应该放在硬盘上的哪个位置呢？难道需要将所有的块扫描一遍，找个空的地方随便放吗？

那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：

- 空闲表法
- 空闲链表法
- 位图法

### 空闲表法

空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：



![img](https://pic3.zhimg.com/80/v2-1ec1e7e0b313a92e0028691ae97c9766_720w.jpg)



当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。

这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。

### 空闲链表法

我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：



![img](https://pic3.zhimg.com/80/v2-a14c65a4ec2fbb470fba728b818a6d22_720w.jpg)



**当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上**。

这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。

空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。

### 位图法

位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，**磁盘上所有的盘块都有一个二进制位与之对应**。

当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：

```text
1111110011111110001110110111111100111 ...
```

在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。