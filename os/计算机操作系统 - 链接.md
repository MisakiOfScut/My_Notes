# 计算机操作系统 - 链接
<!-- GFM-TOC -->
* [计算机操作系统 - 链接](#计算机操作系统---链接)
    * [编译系统](#编译系统)
    * [静态链接](#静态链接)
    * [目标文件](#目标文件)
    * [动态链接](#动态链接)
<!-- GFM-TOC -->


## 编译系统


以下是一个 hello.c 程序：

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

在 Unix 系统上，由编译器把源文件转换为目标文件。

```bash
gcc -o hello hello.c
```

这个过程大致如下：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div><br>

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。



## 目标文件

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；



## 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div><br>





### 可重定位目标文件

一个ELF可重定位目标文件由多个节和节头部表组成

<img src="https://tse3-mm.cn.bing.net/th/id/OIP.4LEECsC4TXRFxHD11co6ewHaEO?w=330&h=188&c=7&o=5&dpr=1.25&pid=1.7" alt="可重定位目标文件 的图像结果"  />

- **ELF header**:前16个字节描述了字的大小和生产该文件系统的字节顺序，剩下的包含帮助链接器解析和解释目标文件的信息。
- **.text**:已编译程序的机器代码
- **.rodata**:只读数据
- **.data**:已初始化的全局C变量
- **.bss**:未初始化的全局C变量，不占空间
- **.symtab**:符号表，存放程序中被定义和引用的函数和全局变量的信息。
- **.rel.text**:一个.text节位置列表，保存跟其他文件链接之后需要修改的项
- **.rel.data**:记录被模块定义或引用的全局变量的重定位信息
- **.debug**:调试符号表
- **.line**:源代码行号和.text节中机器码的映射,用于调试.
- **.strtab**:一个字符串表包含.symtab和.debug的符号表还有其节头部名.



### 符号表

符号表包含的符号可分为三种：

- 由模块m定义并能被其他文件引用的`全局符号`
- 其他模块定义然后在m中引用的全局符号即`外部符号`
- 只被模块m定义的`局部符号`即static修饰的全局变量or函数

而函数内非static的局部变量不在其中，这些符号运行时由栈管理



<img src="https://t1.daumcdn.net/cfile/tistory/244298465775D5712B" alt="See the source image"  align="left"/>

ELF符号表包含一个上述格式的条目的数组

- name是字符串表中的字节偏移，指向符号以null结尾的字符串名字
- value是符号的地址，对于ELF来说该值是距离定义目标的节的起始位置的偏移（我们知道每个符号都会被分配到ELF的某个节如.data），在可执行文件中则是绝对运行时地址



### 符号解析

链接器解析符号引用的方法是将每个引用与它的输入的ELF的符号表中的一个确定的符号定义关联起来

（关联以便在重定位时让引用指向正确的运行时地址）

#### 全局符号的解析

在LINUX中函数和已初始化的全局变量是`强符号`，未初始化的全局变量是`弱符号`，规则：

- 不允许多个同名的强符号
- 如果有一个强符号和多个弱符号重名，选择强符号（这是危险的）
- 如果多个弱符号重名，任意选择一个



### 重定位

- 重定位节和符号定义

  链接器将所有相同类型的节合并为同一类型的聚合节，例如所有.data节合并为可执行文件的.data节；将运行时内存赋给模块定义的每个节，以及赋给每个符号，这样程序中的每条指令和全局变量都有唯一的运行时地址了

- 重定位节中的符号引用

  链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址



<img src="C:\Users\misaki\AppData\Roaming\Typora\typora-user-images\image-20210514154531184.png" alt="image-20210514154531184" style="zoom:80%;" />

<center>全局变量、函数的地址</center>

<img src="https://image3.slideserve.com/5625561/linked-elf-executable-object-file-l.jpg" alt="See the source image" style="zoom: 67%;" />

<center>多个可重定位目标文件被链接成了一个可执行目标文件</center>





## 动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div><br>
